#!/usr/bin/env bash
# @spry.nature cap-exec @spry.isCleanable
#
# üëÜ Two things make Spry notice this file:
#   1. The file has its "executable bit" set (`chmod +x`), so the OS can run it.
#   2. The `spry.nature cap-exec` annotation above tells Spry this is a
#      "capturable executable" (CapExec) that should be included in the build.
#
# Spry will automatically scan source files for these annotations. It uses
# the shared `/lib/universal/content` module to read and understand them.
# That module knows how to parse annotations from many types of files, not
# just Bash scripts. Check the README in that library if you need details on
# how annotation scanning works.
#
# üîÑ Auto-materialization:
#   - When Spry runs this file, anything it prints to STDOUT is captured.
#   - If the file name follows the pattern <basename>.<nature>.<runner>
#     (for example: `debug-cap-exec.env.sh`), Spry will automatically
#     write the output into a file named <basename>.auto.<nature>
#     (for example: `debug-cap-exec.auto.env`).
#   - This is the simplest way to produce build artifacts from a CapExec.
#   - If the file is auto-materialized and spry.isCleanable is set, it can be
#     deleted during a `clean` operation.
#   - If the file is not auto-materialized and spry.isCleanable is set, then
#     CAPEXEC_DESTROY_CLEAN env var will be set to 'TRUE' and the cap exec
#     can decide what to do.
#
# üóÇÔ∏è Custom file outputs:
#   - You are not limited to auto-materialization. CapExecs can also write
#     their own single or multiple files wherever they need to.
#   - Spry passes a set of `CAPEXEC_*` environment variables that tell you
#     the proper destinations (for example, the SQLite database file path
#     or the auto-materialize path).
#   - Your script can choose to ignore auto-materialization and instead
#     create files in those locations manually.
#
# In short: this file demonstrates the auto-materialization convention,
# but CapExecs are free to manage their own outputs too. Either way, Spry
# integrates the results into the build pipeline.
# -----------------------------------------------------------------------------
# This debug-cap-exec.env.sh CapExec script exists only as a teaching tool.
# -----------------------------------------------------------------------------
# Purpose:
#   - Show which CAPEXEC_* environment variables Spry injects into a CapExec.
#   - Demonstrate how to flatten complex JSON env vars like CAPEXEC_SOURCE
#     and CAPEXEC_CONTEXT_JSON into human-readable key=value lines.
#   - Confirm that Spry auto-materialization works: because this script follows
#     the <basename>.<nature>.<runner> pattern (e.g. debug-cap-exec.env.sh),
#     its stdout is automatically captured into a generated
#     <basename>.auto.<nature> file during the build.
#
# Key points:
#   - The script does not mutate anything in your project; it only prints.
#   - Output is dynamic (reflecting the current orchestration context).
#   - This is a non-TypeScript CapExec, proving that any language/runtime
#     capable of running as an executable can participate in the Spry pipeline.
#   - The resulting auto-materialized file becomes part of Spry‚Äôs reproducible
#     build artifacts alongside SQLPage content.
#
# In short:
#   This script is a simple "debug viewer" that lets you understand what
#   environment variables and context Spry provides to CapExecs, while showing
#   how non-TypeScript sources integrate seamlessly into the orchestration flow.
# -----------------------------------------------------------------------------

# --- helpers ---
has_jq() { command -v jq >/dev/null 2>&1; }
flatten_json() { # $1=JSON_STRING  $2=PREFIX (e.g., CAPEXEC_SRC or CAPEXEC_CTX)
  local j="$1" pfx="$2"
  if [[ -z "$j" ]]; then echo "${pfx}_ERROR=no JSON provided"; return; fi
  echo "$j" | jq -e . >/dev/null 2>&1 || { echo "${pfx}_ERROR=invalid JSON"; return; }
  echo "$j" | jq -r '
    def is_scalar(v): (v|type) as $t | ($t != "object" and $t != "array");
    def sanitize:
      tostring|ascii_upcase|gsub("[^A-Z0-9]";"_")
      | (if test("^[0-9]") then "_" + . else . end)
      | gsub("_+";"_") | gsub("^_+";"") | gsub("_+$";"");
    paths as $p
    | (getpath($p)) as $v
    | select(is_scalar($v))
    | ($p|map(sanitize)|join("__")) as $k
    | "'"$pfx"'_\($k)=\($v|tostring)"
  ' | sort
}

cat <<EOF
# -----------------------------------------------------------------------------
# Generated by: $(basename "$0")
#
# This output was produced by a CapExec script that runs as part of the Spry
# orchestration pipeline. It demonstrates:
#
#   ‚Ä¢ Which CAPEXEC_* environment variables the Spry engine makes available.
#   ‚Ä¢ How CAPEXEC_SOURCE and CAPEXEC_CONTEXT_JSON can be flattened into
#     deterministic key=value pairs for inspection.
#   ‚Ä¢ That even a non-TypeScript CapExec (here, a Bash script) can generate
#     dynamic, auto-materialized output fully integrated into the Spry build.
#
# The contents below are not static: each run reflects the current Spry
# orchestration context. This file is auto-materialized by Spry following the
# <basename>.auto.<nature> naming convention, so you can check it into source
# control for reproducibility or inspect it to debug orchestration state.
# -----------------------------------------------------------------------------

EOF

# --- exported env (sorted) ---
echo "# CAPEXEC_* (exported env)"
printenv | grep '^CAPEXEC_' | sort || true
echo

# --- CAPEXEC_SOURCE_JSON flattened (sorted) ---
echo "# CAPEXEC_SOURCE_JSON -> CAPEXEC_SRC_*"
if has_jq; then
  flatten_json "${CAPEXEC_SOURCE_JSON:-}" CAPEXEC_SRC
else
  echo "CAPEXEC_SRC_ERROR=jq not available"
fi
echo

# --- CAPEXEC_CONTEXT_JSON flattened (sorted) ---
echo "# CAPEXEC_CONTEXT_JSON -> CAPEXEC_CTX_*"
if has_jq; then
  flatten_json "${CAPEXEC_CONTEXT_JSON:-}" CAPEXEC_CTX
else
  echo "CAPEXEC_CTX_ERROR=jq not available"
fi
